import SHA3 from 'sha3'
import {cbor} from 'cbor-web'
import {sleep} from './misc'
import {Buffer} from 'buffer'

const DEFAULT_OPTIONS_GET_TIMESTAMP = {
  wait: false,
  maxRetries: 5,
  // eslint-disable-next-line require-await
  firstStepCallback: async () => null,
}

const DEFAULT_OPTIONS_VERIFY_TIMESTAMP = {
  online: true,
}


export function createTimestampHash(data: Buffer, timestamp: string) {
  const tsStruct = {
    data,
    timestamp,
    typ: 'ts',
    version: '1',
  }
  return new SHA3(256).update(cbor.encodeCanonical(tsStruct)).digest()
}

function _verifyInclusionProof(_input: ProofInput) {
  let { hash, head, a, path } = _input
  let current = new SHA3(256)
    .update(Buffer.from([0]))
    .update(hash)
    .digest()
  for (const node of path) {
    if ((a & 1) !== 0) {
      current = new SHA3(256)
        .update(Buffer.from([1]))
        .update(node)
        .update(current)
        .digest()
    } else {
      current = new SHA3(256)
        .update(Buffer.from([1]))
        .update(current)
        .update(node)
        .digest()
    }
    a >>= 1
  }
  return current.compare(head) === 0
}

type Base64String = string & { __brand: 'base64' };

interface ProofStringInput {
  ith: Base64String,
  a: number,
  path: Base64String[]
}

interface ProofInput {
  hash: Buffer,
  head: Buffer,
  a: number,
  path: Buffer[],
}

/**
 * Verify a timestamp proof
 * @param hash Hash of timestamp nucleus, a Buffer
 * @param proof ProofStringInput
 * @returns {boolean} True iff hash is verified to be included in ith, per a and path
 */
function verifyTsProof(hash: Buffer, proof: ProofStringInput) {
  const {ith, a, path} = proof
  return _verifyInclusionProof({
    hash,
    head: Buffer.from(ith, 'base64'),
    a,
    path: path.map((item: string) => Buffer.from(item, 'base64')),
  })
}

function verifyIntervalProof(ihash: Buffer, mth: Base64String, _input: {a: number, path: Base64String[]}) {
  const { a, path } = _input
  return _verifyInclusionProof({
    hash: ihash,
    head: Buffer.from(mth, 'base64'),
    a,
    path: path.map((item) => Buffer.from(item, 'base64')),
  })
}

enum SOURCE {
  DIRECT_SET = 'direct'
}


class InconsistencyError extends Error {
  constructor(message: string) {
    super(message)
    this.name = 'InconsistencyError'
  }
}

class TimestampServerError extends Error {
  constructor(message: string) {
    super(message)
    this.name = 'TimestampServerError'
  }
}


export class TimestampService {








  setTrusted(url: string, source: SOURCE = SOURCE.DIRECT_SET) {
    const parsedUrl = parseCompactTs(url)
    if (parsedUrl) {
      this.knownHead = {
        interval: parseInt(parsedUrl.interval),
        mth: parsedUrl.mth,
        source,
      }
    }
  }

  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  amendTree(extensionProof) {}

  async getTimestamp(data: string, options = DEFAULT_OPTIONS_GET_TIMESTAMP) {
    const request = { data }
    const options_ = { ...DEFAULT_OPTIONS_GET_TIMESTAMP, ...options }
    let response = await fetch(
      this.baseUrl + 'v1/ts/' + (options_.wait ? '?wait' : ''),
      {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          Accept: 'application/json',
        },
        body: JSON.stringify(request),
      }
    )
    let ts = null
    if (response) {
      ts = await response.json()
    }
    if (!response || !ts || !ts.id) {
      throw new TimestampServerError('null response from server')
    }
    if (ts && ts.proof) {
      return ts
    }
    await options_.firstStepCallback()
    let retryCounter = 0
    while (retryCounter < 5 && ts && !ts?.proof) {
      const waitTime = Math.max(
        this.estimatedNextTick - new Date(),
        retryCounter === 0 ? 500 : 1000
      )
      await sleep(waitTime)
      response = await fetch(
        this.baseUrl +
          'v1/ts/' +
          ts.id +
          '/' +
          (retryCounter === 0 ? '?wait' : ''),
        {
          headers: {
            Accept: 'application/json',
          },
        }
      )
      if (response) {
        ts = await response.json()
      }
      retryCounter++
    }
    if (ts && ts.proof) {
      const components = parseCompactTs(ts.proof.mth)!
      this.updateState(components.authority, 'mth', {
        interval: components.interval,
        mth: components.mth,
        ith: ts.proof.ith,
        received: new Date(),
      })
      return ts
    }
    throw new TimestampServerError('Timed out waiting for interval from server')
  }

  async verifyTimestamp(data, ts, options = DEFAULT_OPTIONS_VERIFY_TIMESTAMP) {
    const hash = createTimestampHash(data, ts.timestamp)
    if (ts?.hash) {
      if (Buffer.from(ts.hash, 'base64').compare(hash) !== 0) {
        return false
      }
    }
    return verifyTsProof(hash, ts.proof)
  }
}
